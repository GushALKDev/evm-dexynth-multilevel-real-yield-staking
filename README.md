# Dexynth Multilevel Real Yield Staking

## Project Updates (Dec 2025)

### ‚ö°Ô∏è Gas Optimizations & Refactoring
- **Variable Packaging**: Optimized data types (e.g., `uint40` for timestamps, `uint32` for epochs) and reordered state variables/struct members to pack them into fewer storage slots, significantly reducing storage costs.
- **Custom Errors**: Replaced string revert messages with Custom Errors (e.g., `error StakeStillLocked()`) to save deployment and runtime gas.
- **Explicit Types**: Standardized usage of `uint256` instead of implicit `uint` for clarity and consistency.
- **Visibility Optimization**: Refactored public functions to `external` (`stake`, `unstake`, `harvest`, etc.) to reduce gas costs on function calls.
- **Loop Optimization**: Implemented `unchecked` arithmetic in for-loops and epoch math to save gas on increment operations and timestamp calculations.
- **Storage Caching**: Implemented local variable caching for storage reads (SLOAD) in critical loops (`harvest`, `stake`, `checkForClosingEpochs`), minimizing expensive storage access.
- **Code Style & Safety**: Adopted Chainlink-style naming conventions (`s_` for storage, `i_` for immutables) to prevent storage vs. memory confusion and locked compiler version to `0.8.28` for deterministic builds.

#### üìä Gas Performance Improvements
A comparative analysis between the original implementation and the final optimized version (v2) demonstrates massive gas savings across key operations:

| Operation | Original Gas | Optimized Gas (v2) | Savings | Improvement |
| :--- | :--- | :--- | :--- | :--- |
| **Stake** | 260,117 | 177,177 | **-82,940** | **~31.9%** üìâ |
| **Unstake** | 3,259,956 | 1,471,062 | **-1,788,894** | **~54.9%** üìâ |
| **Harvest** | 524,517 | 308,142 | **-216,375** | **~41.3%** üìâ |

> *Note: `Unstake` and `Harvest` costs vary heavily depending on the number of epochs to process. The optimized version handles multi-epoch calculations significantly more efficiently.*

### üß™ Advanced Testing Strategy
- **Fuzzing Tests**: Implemented property-based testing using Foundry's Fuzzing capabilities (`testFuzz_Stake`, `testFuzz_Unstake`, `testFuzz_Harvest`). This allows testing the contract against thousands of random input combinations to ensure robustness and edge-case handling.
- **State-Dependent Fuzzing**: Created complex fuzzing scenarios that simulate time passage and state changes (staking -> waiting -> unstaking/harvesting) to verify logic consistency over time.
- **Advanced Scenarios**: Added `testFuzz_MultipleStakes` to verify state consistency with multiple deposits and `testFuzz_DynamicRewards` to validate reward logic under randomized reward injection rates.

### üõ†Ô∏è Tooling Migration: Hardhat ‚Üí Foundry
- **Complete Migration**: Replaced Hardhat with **Foundry** for a faster and more robust development environment.
- **Solidity-Native Testing**: Ported all JavaScript tests to Solidity (`DexynthStaking.t.sol`), enabling direct interaction with contracts and faster execution.
- **Improved Testing Infrastructure**:
  - Added `vm.warp` for precise time manipulation in tests.
  - Configured `via_ir = true` for better optimization.
  - Set up Mock ERC20 tokens (`DEXY`, `USDT`) for isolated testing.

## Running the Project

### Prerequisites
- [Foundry](https://book.getfoundry.sh/getting-started/installation)

### Build
```bash
forge build
```

### Test
Run the full test suite (Unit + Fuzzing):
```bash
forge test
```

Run with gas report:
```bash
forge test --gas-report
```

---

## Overview

**Dexynth Multilevel Real Yield Staking** is a staking smart contract designed to distribute **Real Yield** in the form of USDT. Users stake their DEXY tokens and choose a lock-up period (level), which determines their reward multiplier. The longer the lock, the higher the share of the rewards pool they receive.

To ensure the correctness of the staking model and reward logic, the design was first created in an **Excel spreadsheet**, where all calculations were tested under various scenarios. This spreadsheet provided a clear blueprint for the contract implementation and was later validated through a comprehensive **unit test suite** to compare the expected and actual values generated by the contract.

## Key Features

- **Stake and Unstake**: Users can lock $DEXY tokens in the contract and withdraw them after the lock period ends.  
- **Reward Scaling**: Rewards increase based on staking level, incentivizing longer lock durations with higher returns.  
- **Epoch-Based Distribution**: Rewards and staking mechanics are organized into distinct time intervals (epochs).  
- **Administrative Control**: Administrators can add rewards to the pool and adjust contract parameters.

---

## Staking Levels

The contract offers five staking levels, each with different lock periods and reward boosts:

| **Level** | **Lock Period** | **Multiplier** |
|-----------|-----------------|----------------|
| 0         | 30 days         | 0.65x          |
| 1         | 90 days         | 0.85x          |
| 2         | 180 days        | 1.00x          |
| 3         | 1 year          | 1.15x          |
| 4         | 2 years         | 1.35x          |

---

## Core Methods

### **Staking**
Allows users to lock $DEXY tokens in a specific staking level.  
```solidity
function stake(uint256 _amount, uint8 _level) external;
```
- `_amount`: Number of $DEXY tokens to stake (18 decimals).  
- `_level`: Desired staking level (0-4).  

### **Unstaking**
Enables users to withdraw their staked tokens after the lock period ends.  
```solidity
function unstake(uint64 _stakeIndex) external;
```
- `_stakeIndex`: Index of the user's staking position.

### **Harvesting Rewards**
Lets users claim accumulated $USDT rewards.  
```solidity
function harvest() public;
```
### **Adding Rewards**  
Allows administrators to deposit $USDT rewards into the staking pool.  
```solidity
function addStakingReward(uint256 _amount) external;
```
- `_amount`: Amount of $USDT to add to the pool (18 decimals).

---

## Validation Process: From Excel to Unit Tests  

### **Excel Design**  
The design of the staking contract was first created in an Excel model to simulate and confirm the expected mechanics of the staking system. This allowed for:  
- Simulating rewards for various staking levels and lock periods.  
- Testing scenarios with multiple users staking and unstaking simultaneously.  
- Ensuring token distribution adhered to predefined parameters.  

The Excel model served as a reference for comparison with unit-tests and on-chain results, helping ensure the contract logic was implemented correctly.

![Excel model 1](./images/staking_excel_1.png)

![Excel model 2](./images/staking_excel_2.png)

![Excel model 1](./images/staking_excel_3.png)

---

### **Unit Tests & Fuzzing**  
After validating the logic in Excel, unit tests were created to replicate and rigorously verify the functionality on-chain. The tests, found in [DexynthStaking.t.sol](./test/DexynthStaking.t.sol), focus on critical aspects of the contract, including:

1. **Staking Functionality**  
   - Ensures users can stake $DEXY tokens at any of the defined levels (0-4).  
   - Validates proper updates to staking balances, timestamps, and lock periods.  

2. **Unstaking Behavior**  
   - Confirms users can only unstake their tokens after the defined lock period.  
   - Verifies that early unstaking attempts are correctly rejected.  

3. **Reward Accrual and Distribution**  
   - Matches reward calculations to the Excel model's projections.  
   - Tests for the correct behavior when the reward pool is depleted.

4. **Harvesting Rewards**  
   - Ensures users can claim rewards without unstaking their tokens.  
   - Validates that rewards do not exceed the available balance in the reward pool.

5. **Administrative Functions**  
   - Confirms that only authorized accounts can add rewards or update parameters.  
   - Prevents unauthorized access to sensitive functions.

6. **Edge Cases**  
   - Prevents staking of zero tokens.  
   - Handles cases where rewards have been exhausted gracefully.

![Staking tests](./images/staking_tests.png)

---

## Security Considerations  

The contract implements various security features to protect against vulnerabilities:  
- **Reentrancy Protection**: The `ReentrancyGuard` modifier is used to prevent reentrancy attacks.  
- **Safe Transfers**: The `SafeERC20` library ensures secure interactions with ERC20 tokens.  
- **Access Control**: Administrative actions are restricted to designated roles, mitigating unauthorized changes.

---

## Additional Notes  

This contract has been validated through multiple layers of testing and simulation. Continuous auditing and monitoring are advised to ensure robustness as the system evolves.
